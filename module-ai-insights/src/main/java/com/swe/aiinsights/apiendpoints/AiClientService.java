/**
 * Authors : Abhirami R Iyer
 */
package com.swe.aiinsights.apiendpoints;


import com.fasterxml.jackson.databind.JsonNode;
import com.swe.aiinsights.data.WhiteBoardData;
import com.swe.aiinsights.request.AiDescriptionRequest;
import com.swe.aiinsights.request.AiRegularisationRequest;
import com.swe.aiinsights.request.AiInsightsRequest;
import com.swe.aiinsights.request.AiSummarisationRequest;
import java.util.concurrent.CompletableFuture;
import com.swe.aiinsights.request.AiQuestionAnswerRequest;
import java.util.List;
import java.util.stream.Collectors;
import java.util.concurrent.CompletableFuture;


import java.io.IOException;
import java.nio.file.Path;

/**
 * AI client service.
 * contains the api endpoints for all the services offered by the AI module.
 */

public class AiClientService {


    private AsyncAiExecutor asyncExecutor = new AsyncAiExecutor();
    /**
     * Accumulates all summaries.
     */
    private String accumulatedSummary = "";

    /**
     * Tracks the completion of the last operation that updated accumulatedSummary.
     * Ensures all summaries are processed sequentially before being queried.
     */
    private CompletableFuture<Void> lastSummaryUpdate = CompletableFuture.completedFuture(null);
    /**
     * Tracks the completion of the last Q&A operation.
     * Ensures questions are processed sequentially.
     */
    private CompletableFuture<Void> lastQaUpdate = CompletableFuture.completedFuture(null);



    /**
     * Interprets an uploaded image and generates a textual description.
     *
     * @param file uploaded image file (from client)
     * @return textual description of the image
     */
    public CompletableFuture<String> describe(final Path file) {
        try {


            // Pass file path to your existing data class
            WhiteBoardData data = new WhiteBoardData(file.toString());
            return asyncExecutor.execute(new AiDescriptionRequest(data));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Regularises a set of input points to produce a smoother output.
     *
     * @param points JSON string containing the points data
     * @return regularised point data as a response
     */
    public  CompletableFuture<String> regularise(final String points) {
        try {
            return asyncExecutor.execute(new AiRegularisationRequest(points));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    /**
     * API for sentiment analysis.
     * Recieves chats as a json file, does sentiment analysis,
     * and generates insights graph
     * @param chatData JSON object containing the chat data
     * @return a list float values to plot in the sentiment graph.
     */
    public  CompletableFuture<String> sentiment(
            final JsonNode chatData){
        try {
            return asyncExecutor.execute(new AiInsightsRequest(chatData));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Summarises chat-based text content asynchronously.
     *
     * @param jsonContent the chat messages in JSON format
     * @return summary text generated by the AI (future only completes after accumulation)
     */
    public CompletableFuture<String> summariseText(final String jsonContent) {
        try {
            CompletableFuture<String> future =
                    asyncExecutor.execute(new AiSummarisationRequest(jsonContent));

            // Chain this summary to the last one and update the tracker
            lastSummaryUpdate = lastSummaryUpdate.thenCompose(v ->
                    future.thenApply(response -> {
                        // Accumulate summaries
                        if (accumulatedSummary == null || accumulatedSummary.isEmpty()) {
                            accumulatedSummary = response;
                        } else {
                            accumulatedSummary = accumulatedSummary + "+" + response;
                        }

//                        System.out.println("Accumulated Summary: " + accumulatedSummary);
                        return null; // Return type is Void
                    })
            );

            // Return the original response for the caller
            return lastSummaryUpdate.thenApply(v -> accumulatedSummary);

        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    /**
     * Clears the accumulated summary.
     *
     * @return confirmation message
     */
    public CompletableFuture<String> clearSummary() {
        accumulatedSummary = "";
        return CompletableFuture.completedFuture(
                "Summary cleared successfully");
    }





    /**
     * Answers a user question asynchronously, conditionally using the
     * accumulated chat summary as context.
     * ENSURES all pending summarization tasks complete before processing the question.
     * ENSURES questions are processed sequentially (one after another).
     *
     * @param question the user's question
     * @return the AI's classified and answered response
     */
    public CompletableFuture<String> answerQuestion(final String question) {
        try {
            // Step 1: Wait for all summaries to complete
            CompletableFuture<String> qaFuture = lastSummaryUpdate.thenCompose(v -> {
                // Step 2: Wait for previous Q&A to complete
                return lastQaUpdate.thenCompose(v2 -> {
                    // Step 3: Now execute this Q&A with complete context
                    AiQuestionAnswerRequest request = new AiQuestionAnswerRequest(
                            question,
                            accumulatedSummary != null ? accumulatedSummary : ""
                    );
                    return asyncExecutor.execute(request);
                });
            });

//            // Step 4: Update the Q&A tracker to point to this operation
//            lastQaUpdate = lastSummaryUpdate.thenCompose(v ->
//                    lastQaUpdate.thenCompose(v2 ->
//                            qaFuture.thenApply(response -> {
//                                System.out.println("Q&A Completed: " + question);
//                                return null; // Void - just tracking completion
//                            })
//                    )
//            );

            // Step 5: Return the answer to the caller
            return qaFuture;

        } catch (Exception e) {
            throw new RuntimeException("Error processing Q&A request", e);
        }
    }


//    // ADD THIS NEW GENERALIZED CHAINING METHOD (The Orchestration Logic)
//    /**
//     * Orchestrates a generalized set of requests, ensuring ALL Summarisation tasks
//     * complete before ANY Question & Answer tasks begin. This enforces context dependency.
//     *
//     * @param summaryFutures A list of futures for all Summary requests.
//     * @param qaFutures A list of futures for all Q&A requests.
//     * @return A CompletableFuture<List<String>> that completes with the final, combined list of results.
//     */
//    public CompletableFuture<List<String>> executeSummaryThenQnA(
//            List<CompletableFuture<String>> summaryFutures,
//            List<CompletableFuture<String>> qaFutures) {
//
//        // 1. Wait for ALL Summaries to complete.
//        CompletableFuture<?>[] summaryArray = summaryFutures.toArray(new CompletableFuture[0]);
//        CompletableFuture<Void> allSummaries = CompletableFuture.allOf(summaryArray);
//
//        // 2. Use thenCompose() to launch and wait for ALL Q&A tasks ONLY after summaries are done.
//        return allSummaries.thenCompose(v -> {
//                    CompletableFuture<?>[] qaArray = qaFutures.toArray(new CompletableFuture[0]);
//                    return CompletableFuture.allOf(qaArray);
//                })
//                // 3. Gather the final results and package them into a single list.
//                .thenApply(v -> {
//                    // Join all futures (which are already complete) and collect summary results
//                    List<String> results = summaryFutures.stream()
//                            .map(CompletableFuture::join)
//                            .map(s -> "SUMMARY: " + s)
//                            .collect(Collectors.toList());
//
//                    // Collect Q&A results
//                    results.addAll(qaFutures.stream()
//                            .map(CompletableFuture::join)
//                            .map(q -> "Q&A: " + q)
//                            .collect(Collectors.toList()));
//
//                    return results;
//                });
//    }
}